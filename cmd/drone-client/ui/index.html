<!--
Copyright (c) 2025 Northbound System
Author: Nicholas Skitch
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Hive Drone - Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .log-entry {
            animation: slideIn 0.3s ease-out;
        }
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div class="flex items-center justify-between mb-8">
            <h1 class="text-3xl font-bold text-gray-900">üêù The Hive Drone Client</h1>
            <div class="flex items-center gap-4">
                <a href="/settings" class="text-blue-600 hover:text-blue-800 font-medium">‚öôÔ∏è Settings</a>
                <span id="serverStatus" class="px-3 py-1 rounded-full text-sm font-semibold bg-gray-200 text-gray-700">
                    <span class="status-dot inline-block w-2 h-2 rounded-full mr-2 bg-gray-500"></span>
                    <span class="status-text">Checking...</span>
                </span>
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <!-- Configuration Panel -->
            <div class="bg-white rounded-lg shadow p-6">
                <h2 class="text-xl font-semibold mb-4">Configuration</h2>
                
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Server Address</label>
                        <input type="text" id="serverAddr" 
                               class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500"
                               placeholder="localhost:50051">
                    </div>

                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Watch Paths</label>
                        <div id="watchPaths" class="space-y-2 mb-2"></div>
                        <div class="flex gap-2">
                            <input type="text" id="newPath" 
                                   class="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500"
                                   placeholder="Add watch path...">
                            <button onclick="addWatchPath()" 
                                    class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">
                                Add
                            </button>
                        </div>
                    </div>

                    <button onclick="saveConfig()" 
                            class="w-full px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700">
                        Save Configuration
                    </button>
                </div>
            </div>

            <!-- Status Panel -->
            <div class="bg-white rounded-lg shadow p-6">
                <h2 class="text-xl font-semibold mb-4">Status</h2>
                <div id="status" class="space-y-2">
                    <p class="text-gray-600">Loading...</p>
                </div>
            </div>
        </div>

        <!-- Notifications Panel -->
        <div class="mt-6 bg-white rounded-lg shadow p-6">
            <h2 class="text-xl font-semibold mb-4">üîî Notifications</h2>
            <div id="notificationsContainer" class="space-y-2 max-h-64 overflow-y-auto">
                <p class="text-gray-500 text-sm italic">No notifications yet</p>
            </div>
        </div>

        <!-- Live Log -->
        <div class="mt-6 bg-white rounded-lg shadow p-6">
            <h2 class="text-xl font-semibold mb-4">Live Log</h2>
            <div id="logContainer" class="bg-gray-900 text-green-400 font-mono text-sm p-4 rounded max-h-96 overflow-y-auto">
                <div class="log-entry">Waiting for events...</div>
            </div>
        </div>
    </div>

    <script>
        let eventSource = null;
        let wasOffline = false; // Track if server was previously offline to prevent spam

        // Load configuration on page load
        async function loadConfig() {
            try {
                const response = await fetch('/api/config');
                const config = await response.json();
                
                document.getElementById('serverAddr').value = config.Server?.Address || config.server?.address || '';
                // Handle both camelCase and snake_case from API
                const paths = config.WatchPaths || config.watch_paths || [];
                updateWatchPaths(paths);
            } catch (error) {
                console.error('Failed to load config:', error);
            }
        }

        // Load status
        async function loadStatus() {
            try {
                const response = await fetch('/api/status');
                const status = await response.json();
                
                const statusDiv = document.getElementById('status');
                statusDiv.innerHTML = `
                    <p><strong>Watching:</strong> ${status.watching_paths?.length || 0} paths</p>
                    <p><strong>Total Files:</strong> ${status.total_files || 0}</p>
                    <p><strong>Processed:</strong> ${status.processed || 0}</p>
                    <p><strong>Errors:</strong> ${status.errors || 0}</p>
                `;
            } catch (error) {
                console.error('Failed to load status:', error);
            }
        }

        // Update watch paths display
        function updateWatchPaths(paths) {
            const container = document.getElementById('watchPaths');
            if (!paths || paths.length === 0) {
                container.innerHTML = '<p class="text-sm text-gray-500 italic">No watch paths configured</p>';
                return;
            }
            container.innerHTML = paths.map((path, index) => {
                // Escape path for HTML attributes (for onclick)
                const escapedForAttr = path.replace(/'/g, "\\'").replace(/"/g, "&quot;").replace(/\n/g, "").replace(/\r/g, "");
                // Escape for HTML display
                const escapedForDisplay = path.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                return `
                <div class="flex items-center justify-between bg-gray-50 px-3 py-2 rounded mb-2" data-path="${escapedForAttr}">
                    <span class="text-sm font-mono text-gray-700 flex-1 truncate" title="${escapedForDisplay}">${escapedForDisplay}</span>
                    <button onclick="removeWatchPath('${escapedForAttr}')" 
                            class="ml-2 px-2 py-1 text-red-600 hover:text-red-800 hover:bg-red-50 text-sm font-semibold rounded transition">
                        Remove
                    </button>
                </div>
            `;
            }).join('');
        }

        // Add watch path
        async function addWatchPath() {
            const input = document.getElementById('newPath');
            const path = input.value.trim();
            if (!path) {
                alert('Please enter a path');
                return;
            }

            try {
                const response = await fetch('/api/watch-paths/add', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({path: path})
                });

                if (response.ok) {
                    input.value = '';
                    // Reload config to show updated list
                    await loadConfig();
                    await loadStatus();
                    // Show success message in log
                    const logContainer = document.getElementById('logContainer');
                    const logEntry = document.createElement('div');
                    logEntry.className = 'log-entry text-blue-400';
                    logEntry.textContent = `[${new Date().toLocaleTimeString()}] Added watch path: ${path}`;
                    logContainer.insertBefore(logEntry, logContainer.firstChild);
                } else {
                    const errorText = await response.text();
                    alert(`Failed to add watch path: ${errorText}`);
                }
            } catch (error) {
                console.error('Error adding watch path:', error);
                alert(`Error: ${error.message}`);
            }
        }

        // Remove watch path
        async function removeWatchPath(path) {
            if (!confirm(`Remove watch path: ${path}?`)) {
                return;
            }

            try {
                const response = await fetch('/api/watch-paths/remove', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({path: path})
                });

                if (response.ok) {
                    await loadConfig();
                    await loadStatus();
                    // Show message in log
                    const logContainer = document.getElementById('logContainer');
                    const logEntry = document.createElement('div');
                    logEntry.className = 'log-entry text-yellow-400';
                    logEntry.textContent = `[${new Date().toLocaleTimeString()}] Removed watch path: ${path}`;
                    logContainer.insertBefore(logEntry, logContainer.firstChild);
                } else {
                    const errorText = await response.text();
                    alert(`Failed to remove watch path: ${errorText}`);
                }
            } catch (error) {
                console.error('Error removing watch path:', error);
                alert(`Error: ${error.message}`);
            }
        }

        // Save configuration
        async function saveConfig() {
            const serverAddr = document.getElementById('serverAddr').value;
            // Get paths from the displayed list
            const paths = Array.from(document.querySelectorAll('#watchPaths .text-sm'))
                .map(el => el.textContent.trim())
                .filter(p => p);

            try {
                const response = await fetch('/api/config/save', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        Server: {Address: serverAddr},
                        WatchPaths: paths,
                        WebServer: {Port: 9091}
                    })
                });

                if (response.ok) {
                    alert('Configuration saved! Watcher will reload.');
                    await loadConfig();
                    await loadStatus();
                } else {
                    const errorText = await response.text();
                    alert(`Failed to save configuration: ${errorText}`);
                }
            } catch (error) {
                console.error('Error saving config:', error);
                alert(`Error: ${error.message}`);
            }
        }

        // Connect to event stream
        function connectEventStream() {
            if (eventSource) {
                eventSource.close();
            }

            eventSource = new EventSource('/api/stream');
            const logContainer = document.getElementById('logContainer');

            eventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    // Handle missing or invalid timestamps
                    let timestamp;
                    if (data.timestamp && data.timestamp !== null && data.timestamp !== undefined) {
                        try {
                            timestamp = new Date(data.timestamp).toLocaleTimeString();
                        } catch (e) {
                            timestamp = new Date().toLocaleTimeString();
                        }
                    } else {
                        timestamp = new Date().toLocaleTimeString();
                    }
                    
                    let className = 'text-green-400';
                    let icon = 'üìÑ';
                    if (data.type === 'file_error') {
                        className = 'text-red-400';
                        icon = '‚ùå';
                    } else if (data.type === 'file_complete') {
                        className = 'text-blue-400';
                        icon = '‚úÖ';
                    } else if (data.type === 'file_detected') {
                        className = 'text-yellow-400';
                        icon = 'üëÅÔ∏è';
                    } else if (data.type === 'file_processing') {
                        className = 'text-cyan-400';
                        icon = '‚öôÔ∏è';
                    } else if (data.type === 'notification') {
                        className = 'text-purple-400';
                        icon = 'üîî';
                        // Also add to notifications panel
                        addNotification(data);
                    }

                    const logEntry = document.createElement('div');
                    logEntry.className = `log-entry ${className}`;
                    const chunksInfo = data.chunks ? ` (${data.chunks} chunks)` : '';
                    logEntry.textContent = `[${timestamp}] ${icon} ${data.message}${chunksInfo}`;
                    
                    logContainer.insertBefore(logEntry, logContainer.firstChild);
                    
                    // Keep only last 100 entries
                    while (logContainer.children.length > 100) {
                        logContainer.removeChild(logContainer.lastChild);
                    }
                } catch (error) {
                    console.error('Error parsing event:', error, event.data);
                }
            };

            eventSource.onerror = function(error) {
                console.error('EventSource error:', error);
                // Reconnect after 3 seconds
                setTimeout(connectEventStream, 3000);
            };
        }

        // Add notification to notifications panel
        function addNotification(data) {
            const container = document.getElementById('notificationsContainer');
            
            // Remove "No notifications yet" message if present
            const noNotifications = container.querySelector('.text-gray-500');
            if (noNotifications) {
                noNotifications.remove();
            }

            const notification = document.createElement('div');
            notification.className = 'bg-yellow-50 border-l-4 border-yellow-400 p-3 rounded';
            
            let levelClass = 'text-yellow-800';
            if (data.level === 'critical') {
                notification.className = 'bg-red-50 border-l-4 border-red-400 p-3 rounded';
                levelClass = 'text-red-800';
            } else if (data.level === 'warning') {
                notification.className = 'bg-yellow-50 border-l-4 border-yellow-400 p-3 rounded';
                levelClass = 'text-yellow-800';
            } else {
                notification.className = 'bg-blue-50 border-l-4 border-blue-400 p-3 rounded';
                levelClass = 'text-blue-800';
            }

            notification.innerHTML = `
                <div class="flex items-start">
                    <div class="flex-1">
                        <p class="font-semibold ${levelClass}">üîî ${data.type || 'Notification'}</p>
                        <p class="text-sm text-gray-700 mt-1">${data.message}</p>
                        <p class="text-xs text-gray-500 mt-1">${new Date().toLocaleString()}</p>
                    </div>
                    <button onclick="this.parentElement.parentElement.remove()" 
                            class="ml-2 text-gray-400 hover:text-gray-600">
                        ‚úï
                    </button>
                </div>
            `;

            container.insertBefore(notification, container.firstChild);

            // Keep only last 20 notifications
            while (container.children.length > 20) {
                container.removeChild(container.lastChild);
            }
        }

        // Initialize
        loadConfig();
        loadStatus();
        connectEventStream();

        // Refresh status every 5 seconds
        setInterval(loadStatus, 5000);

        // Track notification state to prevent spam
        let notificationSent = false;

        // Server status monitoring with timeout
        function updateServerStatus() {
            const statusEl = document.getElementById('serverStatus');
            if (!statusEl) return;
            
            const dotEl = statusEl.querySelector('.status-dot');
            const textEl = statusEl.querySelector('.status-text');
            
            // Create AbortController for timeout
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout
            
            fetch('/api/server-status', { signal: controller.signal })
                .then(response => {
                    clearTimeout(timeoutId);
                    return response.json();
                })
                .then(data => {
                    if (data.status === 'up') {
                        // Server is online - reset notification flag
                        if (wasOffline) {
                            // Server just came back online
                            wasOffline = false;
                            notificationSent = false; // Reset notification flag when back online
                        }
                        statusEl.className = 'px-3 py-1 rounded-full text-sm font-semibold bg-green-200 text-green-700';
                        dotEl.className = 'status-dot inline-block w-2 h-2 rounded-full mr-2 bg-green-500';
                        textEl.textContent = 'Server Online';
                    } else if (data.status === 'down') {
                        // Server is offline - only show notification if not already sent
                        if (!wasOffline) {
                            wasOffline = true;
                        }
                        // Only fire notification if we haven't sent one yet
                        if (!notificationSent) {
                            notificationSent = true;
                            // Could show a notification here if desired, but only once
                        }
                        statusEl.className = 'px-3 py-1 rounded-full text-sm font-semibold bg-red-200 text-red-700';
                        dotEl.className = 'status-dot inline-block w-2 h-2 rounded-full mr-2 bg-red-500';
                        textEl.textContent = 'Server Offline';
                    } else if (data.status === 'config_required') {
                        statusEl.className = 'px-3 py-1 rounded-full text-sm font-semibold bg-orange-200 text-orange-700';
                        dotEl.className = 'status-dot inline-block w-2 h-2 rounded-full mr-2 bg-orange-500';
                        textEl.textContent = 'Config Required';
                    } else if (data.status === 'disabled_on_server') {
                        statusEl.className = 'px-3 py-1 rounded-full text-sm font-semibold bg-yellow-200 text-yellow-700';
                        dotEl.className = 'status-dot inline-block w-2 h-2 rounded-full mr-2 bg-yellow-500';
                        textEl.textContent = 'Access Revoked';
                    } else {
                        statusEl.className = 'px-3 py-1 rounded-full text-sm font-semibold bg-gray-200 text-gray-700';
                        dotEl.className = 'status-dot inline-block w-2 h-2 rounded-full mr-2 bg-gray-500';
                        textEl.textContent = 'Checking...';
                    }
                })
                .catch(err => {
                    clearTimeout(timeoutId);
                    console.error('Failed to fetch server status:', err);
                    
                    // On timeout or error, set to offline - only notify if not already sent
                    if (!wasOffline) {
                        wasOffline = true;
                    }
                    // Only fire notification if we haven't sent one yet
                    if (!notificationSent) {
                        notificationSent = true;
                        // Could show a notification here if desired, but only once
                    }
                    statusEl.className = 'px-3 py-1 rounded-full text-sm font-semibold bg-red-200 text-red-700';
                    dotEl.className = 'status-dot inline-block w-2 h-2 rounded-full mr-2 bg-red-500';
                    textEl.textContent = 'Server Offline';
                });
        }

        // Update server status every 2 seconds
        setInterval(updateServerStatus, 2000);
        updateServerStatus(); // Initial update
    </script>
</body>
</html>

